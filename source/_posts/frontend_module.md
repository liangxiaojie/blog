# 谈谈前端模块化

## 无模块时代

在 ajax 还未提出之前，js 还只是一种“玩具语言”，由 Brendan Eich 花了不到十天时间发明，用来在网页上进行表单校验、实现简单的动画效果等等，你可以回想一下那个网页上到处有公告块飘来飘去的时代。

这个时候并没有前端工程师，服务端工程师只需在页面上随便写写js就能搞定需求。那个时候的前端代码大概像这样：

```
if (xx) {
  //......
} else {
  //......
}

for (var i = 0; i < 10; i++) {
  //......
}

element.onclick = function () {
  //......
}
```

代码简单的堆在一起，只要能从上往下依次执行就可以了。

## 模块萌芽时代

2006年，ajax 的概念被提出，前端拥有了主动向服务端发送请求并操作返回数据的能力，随着 Google 将此概念的发扬光大，传统的网页慢慢的向“富客户端”发展。

前端的业务逻辑越来越多，代码也越来越多，于是一些问题就暴漏了出来。

### 萌芽时代遇到的问题：

#### 全局变量的灾难

小明定义了 `i = 1`

小刚在后续的代码里：`i = 0`

小明在接下来的代码里：`if (i==1) { … } // 悲剧`

#### 恼人的命名冲突

做项目时，常常会将一些通用的、底层的功能抽象出来，独立成一个个函数，比如
```
function each(arr) {
  // 实现代码
}

function log(str) {
  // 实现代码
}
```
并把这些函数统一放在 util.js 里。需要用到时，引入该文件就行。

直到团队越来越大，开始有人抱怨：

小明：我想定义一个 each 方法遍历对象，但页头的 util.js 里已经定义了一个，我的只能叫 eachObject 了，好无奈。

小刚：我自定义了一个 log 方法，为什么小明写的代码就出问题了呢？谁来帮帮我。

#### 依赖关系不好管理

dialog.js 依赖 util.js，标签的书写顺序必须是
```
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="dialog.js"></script>
<script>
  Dialog.init({ /* 传入配置 */ });
</script>
```

顺序不能错，也不能漏写某个，当组件越来越多，依赖越来越多，经常会因为没有引入依赖文件或顺序错误导致各种问题，当团队越来越大，业务越来越复杂后，依赖问题如果不解决，就会成为大问题。

### 萌芽时代的解决方案：

1. 用自执行函数来包装代码

```
modA = function(){
     var a,b; //变量a、b外部不可见
     return {
          add : function(c){
               a + b + c;
          },
          format: function(){
               //......
          }
     }
}()
```

这样function内部的变量就对全局隐藏了，达到是封装的目的。但是这样还是有缺陷的，modA这个变量还是暴漏到全局了，随着模块的增多，全局变量还是会越来越多。

2. java风格的命名空间

为了避免全局变量造成的冲突，人们想到或许可以用多级命名空间来进行管理，于是，代码就变成了这个风格：

```
app.util.modA = xxx;
app.tools.modA = xxx;
app.tools.modA.format = xxx;
```

Yahoo的YUI早期就是这么做的，调用的时候不得不这么写：

```
app.tools.modA.format();
```

这样调用函数，调用链太长增加了记忆负担且繁琐，所以这种方式并没有被很多人采用，YUI后来也不用这种方式了。

3. jQuery风格的匿名自执行函数

```
(function(window){
    //代码

    window.jQuery = window.$ = jQuery;//通过给window添加属性而暴漏到全局
})(window);
```

jQuery的封装风格曾经被很多框架模仿，通过匿名函数包装代码，所依赖的外部变量传给这个函数，在函数内部可以使用这些依赖，然后在函数的最后把模块自身暴漏给window。
如果需要添加扩展，则可以作为jQuery的插件，把它挂载到$上。
这种风格虽然灵活了些，但并未解决根本问题：所需依赖还是得外部提前提供、还是增加了全局变量。

## 模块化面临什么问题

从以上的尝试中，可以归纳出js模块化需要解决那些问题：

1. 如何安全的包装一个模块的代码？（不污染模块外的任何代码）
2. 如何唯一标识一个模块？
3. 如何优雅的把模块的API暴漏出去？（不能增加全局变量）
4. 如何方便的使用所依赖的模块？

围绕着这些问题，js模块化开始了一段艰苦而曲折的征途。

## 源自 nodejs 的规范 CommonJs

2009年，nodejs横空出世，开创了一个新纪元，人们可以用js来编写服务端的代码了。如果说浏览器端的js即便没有模块化也可以忍的话，那服务端是万万不能的。
大牛云集的CommonJs社区发力，制定了 [Modules/1.0 规范](http://wiki.commonjs.org/wiki/Modules/1.0)，首次定义了一个模块应该长啥样。具体来说，Modules/1.0规范包含以下内容：
1. 模块的标识应遵循的规则（书写规范）
2. 定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的API
3. 如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖
4. 如果引入模块失败，那么require函数应该报一个异常
5. 模块通过变量exports来向往暴漏API，exports只能是一个对象，暴漏的API须作为此对象的属性。
此规范一出，立刻产生了良好的效果，由于其简单而直接，在nodejs中，这种模块化方案立刻被推广开了。

遵循commonjs规范的代码看起来是这样的：（来自官方的例子）

```
//math.js
exports.add = function() {
    var sum = 0, i = 0, args = arguments, l = args.length;
    while (i < l) {
        sum += args[i++];
    }
    return sum;
};
```

```
//increment.js
var add = require('math').add;
exports.increment = function(val) {
    return add(val, 1);
};
```

```
//program.js
var inc = require('increment').increment;
var a = 1;
inc(a); // 2
```

## 服务端向前端进军

Modules/1.0规范源于服务端，无法直接用于浏览器端，原因表现为：
1. 外层没有function包裹，变量全暴漏在全局。如上面例子中increment.js中的add。
2. 资源的加载方式与服务端完全不同。服务端require一个模块，直接就从硬盘或者内存中读取了，消耗的时间可以忽略。而浏览器则不同，需要从服务端来下载这个文件，然后运行里面的代码才能得到API，需要花费一个http请求，也就是说，require后面的一行代码，需要资源请求完成才能执行。由于浏览器端是以插入`<script>`标签的形式来加载资源的（ajax方式不行，有跨域问题），没办法让代码同步执行，所以像commonjs那样的写法会直接报错。

所以，社区意识到，要想在浏览器环境中也能模块化，需要对规范进行升级。

### AMD

AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范

由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是RequireJS 在推广过程中对模块定义的规范化的产出

RequireJS 主要解决两个问题：

1. 实现js文件的异步加载，避免网页失去响应；js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长
2. 管理模块之间的依赖性，多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器，便于代码的编写和维护。

```
//定义模块myModule.js
define(['依赖1，依赖2，依赖3']，function(依赖1，依赖2，依赖3){
    var name = 'tail';
    function printName(){
        console.log(name);
    }

    return {
        printName: printName
    };
})

//加载模块
require(['myModule'],function(my){
  my.printName(); });
})
```

语法

requireJS定义了一个函数 define，它是全局变量，用来定义模块

define(id?, dependencies?, factory);

id: 定义模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。
依赖dependencies: 是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。 依赖参数是可选的，如果忽略此参数，它应该默认为["require", "exports", "module"]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。
工厂方法factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。
在页面上使用require函数加载模块

require([dependencies], function(dependencies){});
require()函数接受两个参数

第一个参数是一个数组，表示所依赖的模块
第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块
require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。

### CMD

CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同

语法

Sea.js 推崇一个模块一个文件，遵循统一的写法

define

```
define(id?, deps?, factory)
```

因为CMD推崇

一个文件一个模块，所以经常就用文件名作为模块id
CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写，factory有三个参数
```
function(require, exports, module)
```

require

require 是 factory 函数的第一个参数

require(id)
require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口

exports

exports 是一个对象，用来向外提供模块接口

module

module 是一个对象，上面存储了与当前模块相关联的一些属性和方法

//定义模块
define(function(require, exports, module){
  var $ = require('jquery.js')
  $('div').removeClass('active')
})

 //加载模块
seajs.use(['myModule.js'], function(my){

})

### AMD与CMD区别

关于这两个的区别网上可以搜出一堆文章，简单总结一下

最明显的区别就是在模块定义时对依赖的处理不同

AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块
CMD推崇就近依赖，只有在用到某个模块的时候再去require
这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法

AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同

很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略

为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）

同样都是异步加载模块，AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行

CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的

这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因

## 面向未来的ES6模块标准

既然模块化开发的呼声这么高，作为官方的ECMA必然要有所行动，js模块很早就列入草案，终于在2015年6月份发布了ES6正式版。然而，可能由于所涉及的技术还未成熟，ES6移除了关于模块如何加载/执行的内容，只保留了定义、引入模块的语法。所以说现在的ES6 Module还只是个雏形，半成品都算不上。但是这并不妨碍我们先窥探一下ES6模块标准。
定义一个模块不需要专门的工作，因为一个模块的作用就是对外提供API，所以只需用exoprt导出就可以了：

```
//方式一, a.js
export var a = 1;
export var obj = {name: 'abc', age: 20};
export function run(){....}
```

```
//方式二, b.js
var a = 1;
var obj = {name: 'abc', age: 20};
function run(){....}
export {a, obj, run}
```

使用模块的时候用import关键字，如：

```
import {run as go} from  'a'
run()
```

如果想要使用模块中的全部API，也可以不必把每个都列一遍，使用module关键字可以全部引入，用法：

```
module foo from 'a'
console.log(foo.obj);
a.run();
```

在花括号中指明需使用的API，并且可以用as指定别名。

ES6 Module的基本用法就是这样，可以看到确实是有些薄弱，而且目前还没有浏览器能支持，只能说它是面向未来了。

目前我们可以使用一些第三方模块（如 babel）来对ES6进行编译，转化为可以使用的ES5代码，或者是符合AMD规范的模块，不过这都是一些临时的方案，或许明年ES7一发布，模块的加载有了标准，浏览器给与了实现，这些工具也就没有用武之地了。

未来还是很值得期待的，从语言的标准上支持模块化，js就可以更加自信的走进大规模企业级开发。

## 小结：

除了解决命名冲突和依赖管理，前端模块化开发还可以带来很多好处：
- 提高代码可维护性：模块化可以让每个文件的职责单一，提高代码可读性，降低代码耦合度，提高代码可复用性，非常有利于代码的维护。
- 模块的版本管理：通过别名等配置，配合构建工具，可以比较轻松地实现模块的版本管理。
- 前端性能优化：通过异步加载模块，这对页面性能非常有益。
- 跨环境共享模块：CMD 模块定义规范与 Node.js 的模块规范非常相近。可以很方便实现模块的跨服务器和浏览器共享。
- 以最少的模块，更快速的满足更多个性化的需求。

模块化开发并不是新鲜事物，但在 Web 领域，前端开发是新生岗位，一直处于比较原始的刀耕火种时代。直到最近几年，随着 Dojo、YUI3、Node.js 等社区的推广和流行，前端的模块化开发理念才逐步深入人心。
